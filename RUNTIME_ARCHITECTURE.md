# Runtime Paths & Architecture Explanation

This document details the technical implementation of file paths, resource handling, and the portable runtime architecture for the `TexasSolver TUI`.

## 1. The "Runtime Folder" Concept
The goal was to create a self-contained directory (`Texas_soverTui_Runtime`) that can be moved anywhere and still function correctly. This required decoupling the application from the source code directory structure.

### Directory Structure
```
Texas_soverTui_Runtime/
├── texas_solver_tui          # The compiled Rust executable
├── strategy.json             # Output file generated by the solver (created at runtime)
├── TexasSolver-v0.2.0-MacOs/ # The C++ Solver Binary Directory
│   └── console_solver        # The actual C++ executable
└── resources/                # Configuration and Data
    ├── text/
    │   └── job_config.txt    # Job file generated by Rust for C++ solver
    └── outputs/              # (Legacy output folder, mostly unused now)
```

## 2. Path Handling Implementation

### A. Relative Paths vs. Absolute Paths
Previously, the code used paths like `../resources/` assuming it was running from the `src` or `target` directory.
**Change:** All paths were updated to be relative to the **Current Working Directory (CWD)**.
*   **Code:** `const RESOURCE_DIR: &str = "resources";`
*   **Effect:** The application looks for `resources` in the folder where the executable is *run*, not where it was *built*.

### B. The `strategy.json` Path
*   **Old Behavior:** Dumped to `resources/outputs/strategy.json`.
*   **New Behavior:** Dumped to `./strategy.json` (root of runtime folder).
*   **Implementation:**
    *   In `solver.rs`, the `dump_result` command sent to the C++ solver is now `dump_result strategy.json`.
    *   The Rust code reads the result from `const OUTPUT_JSON_PATH: &str = "./strategy.json";`.
    *   **Why?** This simplifies access and avoids potential issues with subdirectory creation or relative path resolution in the C++ binary.

### C. The `job_config.txt` Path
*   **Path:** `resources/text/job_config.txt`.
*   **Flow:**
    1.  Rust generates the job configuration string.
    2.  Rust writes this string to `resources/text/job_config.txt`.
    3.  Rust invokes the C++ solver with `--input_file resources/text/job_config.txt`.

## 3. The "Current Directory" Bug Fix
A critical issue prevented the standalone executable from working initially.

*   **The Bug:** The code contained `.current_dir(env!("CARGO_MANIFEST_DIR"))`.
    *   `env!("CARGO_MANIFEST_DIR")` is resolved at **compile time** to the path of the source code on the developer's machine.
    *   When running the executable in the Runtime folder, it would forcefully change its working directory *back* to the source code folder.
    *   This caused it to read/write files in the wrong place and fail if the source folder wasn't present.
*   **The Fix:** Removed the `.current_dir(...)` call entirely.
    *   Now, the child process (C++ solver) inherits the CWD of the parent (Rust TUI).
    *   If you run `./texas_solver_tui` from `Texas_soverTui_Runtime`, the CWD is `Texas_soverTui_Runtime`, and all relative paths (`resources/...`) resolve correctly within that folder.

## 4. Execution Stability (Hang Fix)
We encountered an issue where the application would hang indefinitely.

*   **Cause:** Using `.spawn()` with `.stdout(Stdio::piped())` but not actively reading the stdout stream.
    *   The C++ solver prints a lot of progress data (progress bars).
    *   When the OS pipe buffer filled up, the C++ solver blocked (paused) waiting for the Rust app to read the data.
    *   The Rust app was waiting for the C++ solver to finish (`.wait()`).
    *   Result: **Deadlock**.
*   **Fix:** Switched to `.output()`.
    *   `Command::new(...).output()` captures all stdout and stderr into memory and waits for the process to exit.
    *   This automatically handles the buffering, preventing the deadlock.
    *   Alternatively, removing `.stdout(Stdio::piped())` would allow output to flow to the terminal, also fixing the hang. We chose `.output()` to capture and handle errors gracefully if needed, or to keep the TUI clean.

## 5. Summary of Code Changes for Runtime Support
*   **`src/solver.rs`**:
    *   Updated `JOB_FILE_PATH` and `OUTPUT_JSON_PATH` constants.
    *   Updated `build_job_content` to use `dump_result strategy.json`.
    *   Updated `run_sample_job` to remove `.current_dir` and use `.output()`.
*   **`src/ui/flow.rs`**:
    *   Updated to read from `./strategy.json`.

This architecture ensures that `Texas_soverTui_Runtime` is a truly portable, "unzip-and-run" package.
